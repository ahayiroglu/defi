{"version":3,"sources":["webpack://defi/webpack/bootstrap","webpack://defi/./src/_helpers/foreach.js","webpack://defi/./node_modules/@babel/runtime/helpers/typeof.js","webpack://defi/./src/_core/defs.js","webpack://defi/./src/_helpers/checkobjecttype.js","webpack://defi/./node_modules/@babel/runtime/helpers/defineProperty.js","webpack://defi/./src/_helpers/forown.js","webpack://defi/./src/trigger/_triggerone.js","webpack://defi/./node_modules/@babel/runtime/helpers/slicedToArray.js","webpack://defi/./src/_helpers/defierror.js","webpack://defi/./src/_core/init.js","webpack://defi/./src/_core/defineprop.js","webpack://defi/./src/off/_removelistener.js","webpack://defi/./src/_mq/index.js","webpack://defi/./src/on/_addlistener.js","webpack://defi/./src/set.js","webpack://defi/./src/on/_domeventregexp.js","webpack://defi/./src/_mq/_init.js","webpack://defi/./src/_mq/_data.js","webpack://defi/./src/_helpers/assign.js","webpack://defi/./src/off/_undelegatelistener.js","webpack://defi/./src/_helpers/debounce.js","webpack://defi/./src/on/_delegatelistener/index.js","webpack://defi/./src/unbindnode/index.js","webpack://defi/./src/binders/input.js","webpack://defi/./src/_lib.js","webpack://defi/./src/off/index.js","webpack://defi/./src/_mq/_html2nodelist.js","webpack://defi/./src/_helpers/slice.js","webpack://defi/./src/_helpers/is.js","webpack://defi/./src/on/_addtreelistener.js","webpack://defi/./src/off/_removetreelistener.js","webpack://defi/./src/bindnode/_getnodes.js","webpack://defi/./src/lookforbinder.js","webpack://defi/./src/defaultbinders.js","webpack://defi/./src/index.js","webpack://defi/./src/on/index.js","webpack://defi/./node_modules/@babel/runtime/helpers/arrayWithHoles.js","webpack://defi/./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js","webpack://defi/./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js","webpack://defi/./node_modules/@babel/runtime/helpers/arrayLikeToArray.js","webpack://defi/./node_modules/@babel/runtime/helpers/nonIterableRest.js","webpack://defi/./src/off/_removedomlistener.js","webpack://defi/./src/_mq/parsehtml.js","webpack://defi/./src/_mq/on.js","webpack://defi/./src/_mq/off.js","webpack://defi/./src/_mq/add.js","webpack://defi/./src/on/_adddomlistener.js","webpack://defi/./src/on/_createdomeventhandler.js","webpack://defi/./src/on/_delegatelistener/changehandler.js","webpack://defi/./src/trigger/index.js","webpack://defi/./src/trigger/_triggerdomevent.js","webpack://defi/./src/trigger/_triggeronedomevent.js","webpack://defi/./src/calc/index.js","webpack://defi/./src/calc/_addsource.js","webpack://defi/./src/calc/_createcalchandler.js","webpack://defi/./src/_helpers/deepfind.js","webpack://defi/./src/bindnode/index.js","webpack://defi/./src/bindnode/_selectnodes.js","webpack://defi/./src/bindnode/_createbindingswitcher.js","webpack://defi/./src/unbindnode/_removebinding.js","webpack://defi/./src/bindnode/_bindsinglenode.js","webpack://defi/./src/binders/textarea.js","webpack://defi/./src/binders/select.js","webpack://defi/./src/binders/progress.js","webpack://defi/./src/binders/output.js","webpack://defi/./src/bindnode/_createnodehandler.js","webpack://defi/./src/bindnode/_createobjecthandler.js","webpack://defi/./src/bound.js","webpack://defi/./src/remove.js","webpack://defi/./src/mediate.js","webpack://defi/./src/chain.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","arr","callback","length","_typeof","obj","iterator","constructor","WeakMap","method","typeofObject","defiError","configurable","writable","keys","triggerOne","triggerArgs","def","defs","events","Array","latestEvent","apply","info","arrayWithHoles","require","iterableToArrayLimit","unsupportedIterableToArray","nonIterableRest","getTypeError","variable","variableName","expectedType","bindingErrorPrefix","calcErrorPrefix","errors","node","selectorInfo","target","sourceKey","sourceObject","source","data","getError","Error","objectId","props","id","set","propDef","mediator","bindings","v","fromSetter","allEvents","retain","noTrigger","nameIsString","domEventExecResult","domEventReg","exec","eventName","selector","forOwn","allEventsItem","allEventsName","forEach","event","removeEventData","argCallback","_callback","eventCallback","push","context","Init","parseHTML","assign","on","off","add","propModEventReg","initDefi","skipChecks","existingEvent","test","defineProp","replace","eventOptions","checkObjectType","objVal","objKey","skipMediator","fromMediator","define","force","forceHTML","silent","silentHTML","skipCalc","newValue","previousValue","is","beforechangeStr","beforechangeEventName","changeBindingsEventName","changeStr","changeEventName","changeDepsEventName","changeDelegatedKeyEventName","changeTreeEventName","changeCommonEventName","isChanged","extendedEventOptions","self","triggerChange","MQInit","result","newContext","win","window","nodeType","html2nodeList","querySelectorAll","document","this","nodeIndex","undelegateListener","givenPath","pathStr","delegatedChangeEvtName","delegatedEventName","path","split","slice","join","removeListener","func","givenDelay","thisArg","timeout","delay","args","arguments","callContext","clearTimeout","setTimeout","delegatedData","addListener","evt","changeHandler","unbindNode","itemKey","keyObjValue","keyObjKey","keyObjValueItem","deep","propsItem","propsKey","deepPath","deepPathLength","removeTreeListener","binding","removeBinding","$nodes","getNodes","retainBindings","retainNodes","nodesItem","type","getValue","checked","setValue","trigger","calc","bindNode","bound","remove","mediate","givenNames","isNamesVarArray","namesObjCallback","namesObjName","delegatedName","delegatedEventParts","propName","eventNamespace","$","givenHTML","wrapMap","option","legend","thead","tr","td","col","area","_","html","createElement","optgroup","tbody","tfoot","colgroup","caption","th","ex","wrapper","innerHTML","children","childNodes","arrLike","start","end","_end","j","v1","v2","createTreeListener","newHandler","changeEvent","extendedChangeEvent","restPath","handler","addTreeListener","listenPath","delegateListener","listenedPath","htmlReg","customSelectorReg","selectNodes","defaultBinders","binder","tagName","input","textarea","select","multiple","progress","output","functions","lookForBinder","chain","givenCallback","options","names","triggerOnInit","once","debounceOption","debounce","onceCallback","isArray","_arr","_n","_d","_e","_s","_i","next","done","err","arrayLikeToArray","minLen","toString","from","len","arr2","TypeError","nodes","index","splitBySpaceReg","splitByDotReg","randomID","Math","random","namesStr","delegate","scopeSelector","splittedSelector","matching","sel","setAttribute","matches","webkitMatchesSelector","mozMatchesSelector","msMatchesSelector","oMatchesSelector","removeAttribute","namespace","nodeID","b$","exist","k","addEventListener","removeEventListener","splice","idMap","domEventHandler","createDomEventHandler","fullEventName","bindHandler","unbindHandler","addBindListenerResult","addUnbindListenerResult","domEvent","originalEvent","defiTriggerArgs","which","ctrlKey","altKey","preventDefault","stopPropagation","domEvtExecResult","triggerDomEvent","descendants","descendant","triggerOneDOMEvent","Event","bubbles","cancelable","dispatchEvent","sources","givenHandler","itemTarget","itemSource","itemHandler","itemEventOptions","mergedEventOptions","debouncedCalcHandler","calcHandler","setOnInit","debounceCalcOnInit","debounceCalc","debounceCalcDelay","allSources","syncCalcHandler","createCalcHandler","addSource","sourceKeyItem","exactKey","isDelegated","targetValue","values","protector","protectKey","promiseCalc","setEventOptions","deepFind","Promise","resolve","then","promiseResult","e","paths","current","optional","bindingSwitcher","createBindingSwitcher","oneNode","bindSingleNode","randomAttr","givenSelector","selectors","boundKey","subSelector","boundNodes","execResult","indexOf","selected","previousTarget","lastDeepPathItem","spaceReg","bindingOptions","nodeHandler","objectHandler","destroy","disabled","evtName","foundBinder","givenBinder","getValueOnBind","setValueOnBind","debounceSetValue","debounceGetValue","debounceSetValueOnBind","debounceGetValueOnBind","debounceSetValueDelay","debounceGetValueDelay","useExactBinder","isUndefined","debouncedNodeHandler","debouncedObjectHandler","syncNodeHandler","syncObjectHandler","initialize","createNodeHandler","createObjectHandler","givenValue","textContent","fromNode","changedNode","onChangeValue","evtBinder","dirtyHackValue","all","map","givenKey","prefix","givenKeys","isKeysArray","propMediator","funcNames","funcName","argument","ChainClass"],"mappings":"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","file":"defi.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 34);\n","export default function forEach(arr, callback) {\n    let i = 0;\n    const l = arr.length;\n\n    for (; i < l; i++) {\n        callback(arr[i], i);\n    }\n}\n","function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    module.exports = _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    module.exports = _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nmodule.exports = _typeof;","// object definitions\nexport default new WeakMap();\n","import defiError from './defierror';\n\n// checks type of a variable and throws an error if its type is not an object\nexport default function checkObjectType(object, method) {\n    const typeofObject = object === null ? 'null' : typeof object;\n\n    if (typeofObject !== 'object' && typeofObject !== 'function') {\n        throw defiError('common:object_type', {\n            object,\n            method\n        });\n    }\n}\n","function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nmodule.exports = _defineProperty;","export default function forOwn(obj, callback) {\n    const keys = Object.keys(obj);\n    const l = keys.length;\n    let i = 0;\n    let key;\n\n    while (i < l) {\n        key = keys[i++];\n        callback(obj[key], key);\n    }\n}\n","import defs from '../_core/defs';\n\n// triggers one event\nexport default function triggerOne(object, name, triggerArgs) {\n    const def = defs.get(object);\n    const events = def && def.events[name];\n\n    if (events) {\n        const l = events.length;\n        let i = 0;\n\n        // allow to pass both array of args and single arg as triggerArgs\n        if (triggerArgs instanceof Array) {\n            while (i < l) {\n                const event = triggerOne.latestEvent = events[i];\n                const { callback } = event;\n                callback.apply(object, triggerArgs);\n                i += 1;\n            }\n        } else {\n            while (i < l) {\n                const event = triggerOne.latestEvent = events[i];\n                const { callback } = event;\n                callback.call(object, triggerArgs);\n                i += 1;\n            }\n        }\n    }\n}\n\n// latestEvent is used as required hack in somemethods\ntriggerOne.latestEvent = {\n    info: {},\n    name: null\n};\n","var arrayWithHoles = require(\"./arrayWithHoles\");\n\nvar iterableToArrayLimit = require(\"./iterableToArrayLimit\");\n\nvar unsupportedIterableToArray = require(\"./unsupportedIterableToArray\");\n\nvar nonIterableRest = require(\"./nonIterableRest\");\n\nfunction _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}\n\nmodule.exports = _slicedToArray;","/* eslint-disable prefer-template, max-len */\nconst bindingErrorPrefix = 'Binding error:';\nconst calcErrorPrefix = 'Calc error:';\n\nconst getType = (variable) => {\n    if (variable === null) {\n        return 'null';\n    }\n\n    return typeof variable;\n};\nconst getTypeError = (variable, variableName, expectedType) => `${variableName} must have type \"${expectedType}\" but got \"${getType(variable)}\" instead.`;\n\nconst errors = {\n    'common:object_type': ({ object, method }) => `Error in ${method}: `\n        + getTypeError(object, 'object', 'object'),\n\n    'binding:node_missing': ({ key, node }) => {\n        const selectorInfo = typeof node === 'string' ? ` (given selector is \"${node}\")` : '';\n        return `${bindingErrorPrefix} node is missing for key \"${key}\"${selectorInfo}.`;\n    },\n    'binding:falsy_key': () => `${bindingErrorPrefix} \"key\" arg cannot be falsy`,\n    'calc:target_type': ({ target }) => `${calcErrorPrefix} ${getTypeError(target, 'target key', 'string')}`,\n    'calc:source_key_type': ({ sourceKey }) => `${calcErrorPrefix} ${getTypeError(sourceKey, 'source key', 'string')}`,\n    'calc:source_object_type': ({ sourceObject }) => `${calcErrorPrefix} ${getTypeError(sourceObject, 'source object', 'object')}`,\n    'calc:source_type': ({ source }) => `${calcErrorPrefix} ${getTypeError(source, 'source', 'object')}`,\n\n    'remove:key_type': ({ key }) => `Error in remove: ${getTypeError(key, 'key', 'string')}`,\n\n    'mediate:key_type': ({ key }) => `Error in mediate: ${getTypeError(key, 'key', 'string')}`\n};\n\nexport default function defiError(key, data) {\n    const getError = errors[key];\n    if (!getError) {\n        /* istanbul ignore next */\n        throw Error(`Unknown error \"${key}\". Please report about this on Github.`);\n    }\n\n    return new Error(getError(data));\n}\n","import defs from './defs';\n\nlet objectId = 0;\n\n// this is a common function which associates an object with its defi definition\nexport default function initDefi(object) {\n    let def = defs.get(object);\n    if (!def) {\n        def = {\n            // a property name of \"events\" object is an event name\n            // and a value is an array of event handlers\n            events: {\n                /* example: {\n                    callback: function,\n                    name: \"example\",\n                    info: { ...extra data for an event... }\n                } */\n            },\n            // \"props\" contains special information about properties (getters, setters etc)\n            props: {\n                /* example: {\n                    value: object[key],\n                    mediator: null,\n                    bindings: [{\n                        node,\n                        binder,\n                        nodeHandler,\n                        objectHandler,\n                        ...other required info\n                    }]\n                } */\n            },\n            id: objectId\n        };\n\n        objectId += 1;\n\n        defs.set(object, def);\n    }\n\n    return def;\n}\n","import defs from './defs';\nimport set from '../set';\n\n// the function defines needed descriptor for given property\nexport default function defineProp(object, key) {\n    const def = defs.get(object);\n\n    // if no object definition do nothing\n    if (!def) {\n        return null;\n    }\n\n    if (!def.props[key]) {\n        const propDef = def.props[key] = {\n            value: object[key],\n            mediator: null,\n            bindings: null\n        };\n\n        Object.defineProperty(object, key, {\n            configurable: true,\n            enumerable: true,\n            get() {\n                return propDef.value;\n            },\n            set(v) {\n                return set(object, key, v, {\n                    fromSetter: true\n                });\n            }\n        });\n    }\n\n    return def.props[key];\n}\n","import defs from '../_core/defs';\nimport triggerOne from '../trigger/_triggerone';\nimport domEventReg from '../on/_domeventregexp';\nimport forEach from '../_helpers/foreach';\nimport forOwn from '../_helpers/forown';\n\n// removes simple event listener from an object\nexport default function removeListener(object, name, callback, info) {\n    const def = defs.get(object);\n\n    // if no definition do nothing\n    if (!def) {\n        return false;\n    }\n\n    const { events: allEvents } = def;\n    const events = allEvents[name];\n    const retain = [];\n    const noTrigger = name ? name[0] === '_' : false;\n    const nameIsString = typeof name === 'string';\n    const domEventExecResult = nameIsString ? domEventReg.exec(name) : null;\n\n    if (domEventExecResult) {\n        const [, eventName, key, selector] = domEventExecResult;\n        // fixing circular reference issue\n        const removeDomListener = require('./_removedomlistener');\n\n        removeDomListener(object, key, eventName, selector, callback, info);\n\n        return true;\n    }\n\n    // if all events need to be removed\n    if (typeof name === 'undefined') {\n        if (!noTrigger) {\n            forOwn(allEvents, (allEventsItem, allEventsName) => {\n                forEach(allEventsItem, (event) => {\n                    const removeEventData = {\n                        allEventsName,\n                        callback: event.callback\n                    };\n\n                    triggerOne(object, `removeevent:${name}`, removeEventData);\n                    triggerOne(object, 'removeevent', removeEventData);\n                });\n            });\n        }\n\n        // restore default value of \"events\"\n        def.events = {};\n    } else if (events) {\n        // if events with given name are found\n        forEach(events, (event) => {\n            const argCallback = (callback && callback._callback) || callback;\n            const eventCallback = event.callback._callback || event.callback;\n\n            if (argCallback && argCallback !== eventCallback) {\n                // keep event\n                retain.push(event);\n            } else {\n                const removeEventData = {\n                    name,\n                    callback: event.callback\n                };\n\n                if (!noTrigger) {\n                    if (nameIsString) {\n                        triggerOne(object, `removeevent:${name}`, removeEventData);\n                    }\n\n                    triggerOne(object, 'removeevent', removeEventData);\n                }\n            }\n        });\n\n        if (retain.length) {\n            allEvents[name] = retain;\n        } else {\n            delete def.events[name];\n        }\n    }\n\n    return false;\n}\n","import Init from './_init';\nimport parseHTML from './parsehtml';\nimport on from './on';\nimport off from './off';\nimport add from './add';\nimport assign from '../_helpers/assign';\n\n// a tiny jQuery-like library\nexport default function mq(selector, context) {\n    return new Init(selector, context);\n}\n\nmq.parseHTML = parseHTML;\n\nassign(Init.prototype, {\n    on,\n    off,\n    add\n});\n","import initDefi from '../_core/init';\nimport triggerOne from '../trigger/_triggerone';\nimport defineProp from '../_core/defineprop';\nimport domEventReg from './_domeventregexp';\n\n// property modifier event regexp\n// eslint-disable-next-line max-len\nconst propModEventReg = /^_change:deps:|^_change:bindings:|^_change:delegated:|^_change:common:|^_change:tree:|^change:|^beforechange:/;\n\n// adds simple event listener\n// used as core of event engine\nexport default function addListener(object, name, callback, info = {}) {\n    const { events: allEvents } = initDefi(object);\n    const events = allEvents[name];\n    const event = {\n        callback, name, info\n    };\n    const nameIsString = typeof name === 'string';\n\n    // skipChecks is used by internal methods for better performance\n    const { skipChecks = false } = info;\n\n    if (!skipChecks) {\n        const domEventExecResult = nameIsString && domEventReg.exec(name);\n\n        if (domEventExecResult) {\n            const [, eventName, key, selector] = domEventExecResult;\n            // fixing circular reference issue\n            const addDomListener = require('./_adddomlistener');\n\n            addDomListener(object, key, eventName, selector, callback, info);\n\n            return true;\n        }\n    }\n\n    // if there are events with the same name\n    if (events) {\n        if (!skipChecks) {\n            // if there are events with the same data, return false\n            for (let i = 0; i < events.length; i++) {\n                const existingEvent = events[i];\n                const argCallback = (callback && callback._callback) || callback;\n                const eventCallback = existingEvent.callback._callback || existingEvent.callback;\n                if (argCallback === eventCallback) {\n                    return false;\n                }\n            }\n        }\n\n        // if the event isn't found add it to the event list\n        events.push(event);\n    } else {\n        // if there are no events with the same name, create an array with only  one event\n        allEvents[name] = [event];\n    }\n\n    if (nameIsString && propModEventReg.test(name)) {\n        // define needed accessors for KEY\n        defineProp(object, name.replace(propModEventReg, ''));\n    }\n\n    // names prefixed by underscore mean \"private\" events\n    if (!skipChecks && name[0] !== '_') {\n        if (nameIsString) {\n            triggerOne(object, `addevent:${name}`, event);\n        }\n\n        triggerOne(object, 'addevent', event);\n    }\n\n    // if event is added successfully return true\n    return true;\n}\n","import initDefi from './_core/init';\n\nimport defs from './_core/defs';\nimport triggerOne from './trigger/_triggerone';\nimport checkObjectType from './_helpers/checkobjecttype';\nimport is from './_helpers/is';\nimport forOwn from './_helpers/forown';\n\n// the function sets new value for a property\n// since its performance is very critical we're checking events existence manually\nexport default function set(object, key, value, eventOptions) {\n    // throw error when object type is wrong\n    checkObjectType(object, 'set');\n\n    // if no key or falsy key is given\n    if (!key) {\n        return object;\n    }\n\n    // allow to use key-value object as another method variation\n    if (typeof key === 'object') {\n        forOwn(key, (objVal, objKey) => set(object, objKey, objVal, value));\n        return object;\n    }\n\n    eventOptions = eventOptions || {}; // eslint-disable-line no-param-reassign\n    // possible flags, all of them are falsy by default\n    const {\n        skipMediator,\n        fromMediator,\n        define,\n        force,\n        forceHTML,\n        silent,\n        silentHTML,\n        skipCalc\n    } = eventOptions;\n\n    if (define) {\n        // fixing circular ref\n        const defineProp = require('./_core/defineprop');\n        initDefi(object);\n        defineProp(object, key);\n    }\n\n    const def = defs.get(object);\n\n    // if no object definition then make simple assignment\n    if (!def) {\n        object[key] = value;\n        return object;\n    }\n\n    const { props, events } = def;\n    const propDef = props[key];\n\n    // if no property definition then make simple assignment\n    if (!propDef) {\n        object[key] = value;\n        return object;\n    }\n\n    const { value: previousValue, mediator } = propDef;\n\n    let newValue;\n\n    if (mediator && !is(value, previousValue) && !skipMediator && !fromMediator) {\n        newValue = mediator(value);\n    } else {\n        newValue = value;\n    }\n\n    const isChanged = !is(newValue, previousValue);\n\n    // add to eventOptions object some useful properties\n    // we override default eventOptions because some of the properties need to have actual values,\n    // not inherited ones (eg when calc is used)\n    const extendedEventOptions = {\n        ...eventOptions,\n        value: newValue,\n        self: object,\n        previousValue,\n        key,\n        isChanged\n    };\n\n    const triggerChange = (isChanged || force) && !silent;\n\n    // trigger beforechange:KEY and beforechange events\n    if (triggerChange) {\n        const beforechangeStr = 'beforechange';\n        const beforechangeEventName = `${beforechangeStr}:${key}`;\n\n        if (events[beforechangeEventName]) {\n            triggerOne(object, beforechangeEventName, extendedEventOptions);\n        }\n\n        if (events[beforechangeStr]) {\n            triggerOne(object, beforechangeStr, extendedEventOptions);\n        }\n    }\n\n    propDef.value = newValue;\n\n    // triger bindings\n    if (!silentHTML && (isChanged || forceHTML)) {\n        const changeBindingsEventName = `_change:bindings:${key}`;\n        if (events[changeBindingsEventName]) {\n            triggerOne(object, changeBindingsEventName, extendedEventOptions);\n        }\n    }\n\n    // trigger change:KEY and change events\n    if (triggerChange) {\n        const changeStr = 'change';\n        const changeEventName = `${changeStr}:${key}`;\n        if (events[changeEventName]) {\n            triggerOne(object, changeEventName, extendedEventOptions);\n        }\n\n        if (events[changeStr]) {\n            triggerOne(object, changeStr, extendedEventOptions);\n        }\n    }\n\n    // trigger dependencies made by calc method\n    if ((isChanged || force) && !skipCalc) {\n        const changeDepsEventName = `_change:deps:${key}`;\n        if (events[changeDepsEventName]) {\n            triggerOne(object, changeDepsEventName, extendedEventOptions);\n        }\n    }\n\n\n    if (isChanged) {\n        // trigger common delegated events logic\n        const changeDelegatedKeyEventName = `_change:delegated:${key}`;\n        if (events[changeDelegatedKeyEventName]) {\n            triggerOne(object, changeDelegatedKeyEventName, extendedEventOptions);\n        }\n\n        // trigger tree change events logic\n        const changeTreeEventName = `_change:tree:${key}`;\n        if (events[changeTreeEventName]) {\n            triggerOne(object, changeTreeEventName, extendedEventOptions);\n        }\n\n        // trigger other internal change events\n        const changeCommonEventName = `_change:common:${key}`;\n        if (events[changeCommonEventName]) {\n            triggerOne(object, changeCommonEventName, extendedEventOptions);\n        }\n\n        // trigger delegated logic for asterisk events (*.*.*@foo)\n        // TODO: Confusing events names (\"_change:delegated\", \"_change:common:KEY\" etc)\n        const changeDelegatedEventName = '_change:delegated';\n        if (events[changeDelegatedEventName]) {\n            triggerOne(object, changeDelegatedEventName, extendedEventOptions);\n        }\n    }\n\n    return object;\n}\n","// the regexp allows to parse things like \"click::x(.y)\"\n// it's shared between few modules\nexport default /([^::]+)::([^()]+)?(?:\\((.*)\\))?/;\n","import html2nodeList from './_html2nodelist';\n\n// function-constructor of mq library\n// accepts many kinds of arguments (selector, html, function)\nfunction MQInit(selector, context) {\n    const win = window;\n\n    let result;\n\n    if (selector) {\n        if (selector.nodeType || (typeof win === 'object' && selector === win)) {\n            result = [selector];\n        } else if (typeof selector === 'string') {\n            if (/</.test(selector)) {\n                result = html2nodeList(selector);\n            } else if (context) {\n                const newContext = (new MQInit(context))[0];\n\n                if (newContext) {\n                    result = newContext.querySelectorAll(selector);\n                }\n            } else {\n                result = win.document.querySelectorAll(selector);\n            }\n        } else if ('length' in selector) {\n            // if it's something array-like (eg NodeList)\n            result = selector;\n        } else {\n            // this is somethong another (eg Attr)\n            result = [selector];\n        }\n    }\n\n    const length = result && result.length;\n\n    if (length) {\n        for (let i = 0; i < length; i++) {\n            this.push(result[i]);\n        }\n    }\n}\n\nMQInit.prototype = [];\n\nexport default MQInit;\n","// an object allows to share data between modules; it's needed because we use\n// simplified ES modules there and cannot import and share a number\nexport default {\n    nodeIndex: 0,\n    allEvents: {}\n};\n","export default function assign(target, source) {\n    const keys = Object.keys(source);\n    let i = keys.length;\n    let key;\n\n    while (--i >= 0) {\n        key = keys[i];\n        target[key] = source[key];\n    }\n\n    return target;\n}\n","import defs from '../_core/defs';\nimport removeListener from './_removelistener';\nimport slice from '../_helpers/slice';\nimport forEach from '../_helpers/foreach';\n\n// the function removes internally used events such as _asterisk:add\nfunction detatchDelegatedLogic({\n    delegatedEventName,\n    pathStr,\n    allEvents\n}) {\n    const retain = [];\n    const events = allEvents[delegatedEventName];\n\n    forEach(events, (event) => {\n        // pathStr is assigned to info in delegateListener\n        if (event.info.pathStr !== pathStr) {\n            retain.push(event);\n        }\n    });\n\n    if (retain.length) {\n        allEvents[delegatedEventName] = retain;\n    } else {\n        delete allEvents[delegatedEventName];\n    }\n}\n\n// removes delegated event listener from an object by given path\nexport default function undelegateListener(object, givenPath, name, callback, info = {}) {\n    const def = defs.get(object);\n\n    // if no definition do nothing\n    if (!def) {\n        return;\n    }\n\n    const { events: allEvents } = def;\n\n    let path = typeof givenPath === 'string' && givenPath !== '' ? givenPath.split('.') : givenPath;\n\n    if (!path || !path.length) {\n        // if no path then remove listener\n        removeListener(object, name, callback, info);\n    } else {\n        // else do all magic\n        const key = path[0];\n        let pathStr;\n\n        if (path.length > 1) {\n            path = slice(path, 1);\n            pathStr = path.join('.');\n        } else {\n            path = [];\n            pathStr = path[0] || '';\n        }\n\n\n        const delegatedChangeEvtName = `_change:delegated:${key}`;\n        if (allEvents[delegatedChangeEvtName]) {\n            detatchDelegatedLogic({\n                delegatedEventName: delegatedChangeEvtName,\n                pathStr,\n                allEvents\n            });\n        }\n\n        if (typeof object[key] === 'object') {\n            undelegateListener(object[key], path, name, callback, info);\n        }\n    }\n}\n","// Returns a function, that, as long as it continues to be invoked, will not\n// be triggered. The function will be called after it stops being called for\n// N milliseconds.\n// (c) https://davidwalsh.name/javascript-debounce-function\n\nexport default function debounce(func, givenDelay, thisArg) {\n    let timeout;\n    let delay;\n    if (typeof givenDelay !== 'number') {\n        thisArg = givenDelay; // eslint-disable-line no-param-reassign\n        delay = 0;\n    } else {\n        delay = givenDelay || 0;\n    }\n\n    return function debounced() {\n        const args = arguments;\n        const callContext = thisArg || this;\n\n        clearTimeout(timeout);\n\n        timeout = setTimeout(() => func.apply(callContext, args), delay);\n    };\n}\n","import addListener from '../_addlistener';\nimport changeHandler from './changehandler';\nimport slice from '../../_helpers/slice';\n\n// adds delegated event listener to an object by given path\n// TODO Handler uses wrong context\nexport default function delegateListener(object, givenPath, name, callback, info = {}) {\n    // if typeof path is string and path is not empty string then split it\n    let path = typeof givenPath === 'string' && givenPath !== '' ? givenPath.split('.') : givenPath;\n\n    if (!path || !path.length) {\n        // if no path then add simple listener\n        addListener(object, name, callback, info);\n    } else {\n        // else do all magic\n        const key = path[0];\n        let pathStr; // needed for undelegation\n\n        if (path.length > 1) {\n            path = slice(path, 1);\n            pathStr = path.join('.');\n        } else {\n            path = [];\n            pathStr = path[0] || '';\n        }\n\n        const delegatedData = {\n            path,\n            name,\n            callback,\n            info,\n            object\n        };\n\n        // the event is triggered by \"set\";\n        // a new function is created as a handler to make possible\n        // to add the handler multiple times for one key\n        addListener(object, `_change:delegated:${key}`, (evt) => changeHandler(evt), {\n            delegatedData,\n            pathStr\n        });\n\n        // call handler manually\n        changeHandler({\n            value: object[key]\n        }, delegatedData);\n    }\n}\n","import checkObjectType from '../_helpers/checkobjecttype';\nimport defs from '../_core/defs';\nimport getNodes from '../bindnode/_getnodes';\nimport removeTreeListener from '../off/_removetreelistener';\nimport forEach from '../_helpers/foreach';\nimport forOwn from '../_helpers/forown';\nimport removeBinding from './_removebinding';\n\n// unbinds a node\nexport default function unbindNode(object, key, node, eventOptions) {\n    // throw error when object type is wrong\n    checkObjectType(object, 'unbindNode');\n\n    if (key instanceof Array) {\n        /*\n         * accept array of keys\n         * this.unbindNode(['a', 'b', 'c'], node)\n         */\n        forEach(key, (itemKey) => unbindNode(object, itemKey, node, eventOptions));\n\n        return object;\n    }\n\n    if (key && typeof key === 'object') {\n        forOwn(key, (keyObjValue, keyObjKey) => {\n            if (keyObjValue.constructor === Object && 'node' in keyObjValue) {\n                // this.unbindNode({ key: { node: $(), binder } ) }, { silent: true });\n                unbindNode(object, keyObjKey, keyObjValue.node, node);\n            } else if (\n                keyObjValue.constructor === Array\n                && keyObjValue.length\n                && keyObjValue[0].constructor === Object\n                && 'node' in keyObjValue[0]\n            ) {\n                // this.unbindNode({ key: [{ node: $(), binder }] ) }, { silent: true });\n                forEach(keyObjValue, (keyObjValueItem) => {\n                    unbindNode(object, keyObjKey, keyObjValueItem.node, node);\n                });\n            } else {\n                // this.unbindNode({ key: $() }, { silent: true });\n                unbindNode(object, keyObjKey, keyObjValue, node);\n            }\n        });\n        return object;\n    }\n\n    eventOptions = eventOptions || {}; // eslint-disable-line no-param-reassign\n    const { deep } = eventOptions;\n    const def = defs.get(object);\n\n    if (!def) {\n        return object;\n    }\n\n    const { props } = def;\n\n    // allow to pass null or undefined as key\n    // if passed then remove bindings of all keys for given object\n    if (key === null || typeof key === 'undefined') {\n        forOwn(props, (propsItem, propsKey) => {\n            unbindNode(object, propsKey, null, eventOptions);\n        });\n\n        return object;\n    }\n\n    // remove delegated binding\n    if (deep !== false) {\n        const deepPath = key.split('.');\n        const deepPathLength = deepPath.length;\n\n        if (deepPathLength > 1) {\n            let target = object;\n\n            for (let i = 0; i < deepPathLength - 1; i++) {\n                // TODO: Do we need to throw an error when a target is falsy?\n                target = target[deepPath[i]];\n            }\n\n            // TODO: Potential bug! This may undelegate listener for all bindings with the same path\n            // ...(cannot reproduce)\n            removeTreeListener(object, deepPath.slice(0, deepPathLength - 2));\n\n            unbindNode(target, deepPath[deepPathLength - 1], node, eventOptions);\n\n            return object;\n        }\n    }\n\n    const propDef = props[key];\n\n    // when no propdef do nothing\n    if (!propDef) {\n        return object;\n    }\n\n    const { bindings } = propDef;\n\n    // if the property doesn't have any bindings do nothing\n    if (!bindings) {\n        return object;\n    }\n\n    // if no node is pased remove all bindings for given key\n    if (!node) {\n        forEach(bindings, (binding) => {\n            removeBinding({\n                object, key, eventOptions, binding\n            });\n        });\n\n        propDef.bindings = null;\n\n        return object;\n    }\n\n    const $nodes = getNodes(object, node);\n    const retainBindings = [];\n    const retainNodes = [];\n\n    // iterate over all bindngs and compare their node with given nodes\n    forEach($nodes, (nodesItem) => {\n        forEach(bindings, (binding) => {\n            if (binding.node === nodesItem) {\n                removeBinding({\n                    object, key, eventOptions, binding\n                });\n            } else {\n                retainBindings.push(binding);\n                retainNodes.push(nodesItem);\n            }\n        });\n    });\n\n    // update bindings object\n    if (retainBindings.length) {\n        propDef.bindings = retainBindings;\n    } else {\n        propDef.bindings = null;\n    }\n\n    return object;\n}\n","// returns a binder for input element based on its type\nexport default function input(type) {\n    let on;\n    switch (type) {\n        case 'checkbox':\n            return {\n                on: 'click keyup',\n                getValue() {\n                    return this.checked;\n                },\n                setValue(value) {\n                    this.checked = value;\n                }\n            };\n        case 'radio':\n            return {\n                on: 'click keyup',\n                getValue() {\n                    return this.value;\n                },\n                setValue(value) {\n                    this.checked = typeof value !== 'undefined' && this.value === value;\n                }\n            };\n        case 'submit':\n        case 'button':\n        case 'image':\n        case 'reset':\n            return {};\n        case 'hidden':\n            on = null;\n            break;\n        case 'file':\n            on = 'change';\n            break;\n\n            /*\n            case 'text':\n            case 'password':\n            case 'date':\n            case 'datetime':\n            case 'datetime-local':\n            case 'month':\n            case 'time':\n            case 'week':\n            case 'range':\n            case 'color':\n            case 'search':\n            case 'email':\n            case 'tel':\n            case 'url':\n            case 'file':\n            case 'number': */\n        default: // other future (HTML6+) inputs\n            on = 'input';\n    }\n\n    return {\n        on,\n        getValue() {\n            return this.value;\n        },\n        setValue(value) {\n            this.value = value;\n        }\n    };\n}\n","import on from './on';\nimport off from './off';\nimport trigger from './trigger';\nimport calc from './calc';\nimport bindNode from './bindnode';\nimport bound from './bound';\nimport unbindNode from './unbindnode';\nimport set from './set';\nimport remove from './remove';\nimport mediate from './mediate';\n\n\n// the following methods can be used as static methods and as instance methods\nexport {\n    on,\n    off,\n    trigger,\n    calc,\n    bindNode,\n    bound,\n    unbindNode,\n    set,\n    remove,\n    mediate\n};\n","import checkObjectType from '../_helpers/checkobjecttype';\nimport forEach from '../_helpers/foreach';\nimport forOwn from '../_helpers/forown';\nimport defs from '../_core/defs';\nimport removeListener from './_removelistener';\nimport undelegateListener from './_undelegatelistener';\nimport $ from '../_mq';\n\n// removes event listener\nexport default function off(object, givenNames, callback) {\n    // throw error when object type is wrong\n    checkObjectType(object, 'off');\n\n    const isNamesVarArray = givenNames instanceof Array;\n    const def = defs.get(object);\n\n    // allow to pass name-handler object\n    // TODO: Name-handler object passed to off method is non-documented feature\n    if (givenNames && typeof givenNames === 'object' && !isNamesVarArray) {\n        forOwn(givenNames, (namesObjCallback, namesObjName) => off(\n            object, namesObjName, namesObjCallback, callback\n        ));\n        return object;\n    }\n\n\n    if (!givenNames && !callback) {\n        def.events = {};\n\n        forOwn(def.props, ({ bindings }, propName) => {\n            if (bindings) {\n                forEach(bindings, ({ node }) => {\n                    const eventNamespace = def.id + propName;\n                    $(node).off(`.${eventNamespace}`);\n                });\n            }\n        });\n\n        return object;\n    }\n\n    // convert a single event name into array\n    const names = isNamesVarArray ? givenNames : [givenNames];\n\n    forEach(names, (name) => {\n        const delegatedEventParts = typeof name === 'string' && name.split('@');\n        if (delegatedEventParts.length > 1) {\n            const [path, delegatedName] = delegatedEventParts;\n            undelegateListener(object, path, delegatedName, callback);\n        } else {\n            removeListener(object, name, callback);\n        }\n    });\n\n    return object;\n}\n","// converts HTML string to NodeList instance\nexport default function html2nodeList(givenHTML) {\n    // wrapMap is taken from jQuery\n    const wrapMap = {\n        option: [1, '<select multiple=\"multiple\">', '</select>'],\n        legend: [1, '<fieldset>', '</fieldset>'],\n        thead: [1, '<table>', '</table>'],\n        tr: [2, '<table><tbody>', '</tbody></table>'],\n        td: [3, '<table><tbody><tr>', '</tr></tbody></table>'],\n        col: [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],\n        area: [1, '<map>', '</map>'],\n        _: [0, '', '']\n    };\n\n    const html = givenHTML.replace(/^\\s+|\\s+$/g, '');\n    let node = window.document.createElement('div');\n    let i;\n\n    wrapMap.optgroup = wrapMap.option;\n    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\n    wrapMap.th = wrapMap.td;\n\n    const ex = /<([\\w:]+)/.exec(html);\n    const wrapper = (ex && wrapMap[ex[1]]) || wrapMap._;\n\n    node.innerHTML = wrapper[1] + html + wrapper[2];\n\n    i = wrapper[0];\n\n    while (i) {\n        i -= 1;\n        node = node.children[0];\n    }\n\n    return node.childNodes;\n}\n","export default function slice(arrLike, start, end) {\n    const l = arrLike.length;\n    let i = start || 0;\n    const _end = end || l;\n    const arr = Array(_end - i);\n    let j = 0;\n\n    while (i < _end) {\n        arr[j++] = arrLike[i++];\n    }\n\n    return arr;\n}\n","// determines whether two values are the same value\n/* istanbul ignore next */\nconst isPolyfill = (v1, v2) => v1 === 0 && v2 === 0 ? 1 / v1 === 1 / v2 : v1 !== v1 && v2 !== v2 || v1 === v2; // eslint-disable-line\n\nexport default Object.is || isPolyfill;\n","import delegateListener from './_delegatelistener';\nimport removeTreeListener from '../off/_removetreelistener';\n\n// creates tree listener\nfunction createTreeListener({ handler, restPath }) {\n    const newHandler = function treeListener(changeEvent) {\n        const extendedChangeEvent = {\n            restPath,\n            ...changeEvent\n        };\n        const { previousValue, value } = changeEvent;\n\n        // removes listener for all branches of the path on old object\n        if (previousValue && typeof previousValue === 'object') {\n            removeTreeListener(previousValue, restPath, handler);\n        }\n\n        // adds listener for all branches of \"restPath\" path on newly assigned object\n        if (value && typeof value === 'object') {\n            addTreeListener(value, restPath, handler);\n        }\n\n        // call original handler\n        handler.call(this, extendedChangeEvent);\n    };\n\n    newHandler._callback = handler;\n\n    return newHandler;\n}\n\n// listens changes for all branches of given path\n// one of the most hard functions to understand\nexport default function addTreeListener(object, deepPath, handler) {\n    if (typeof deepPath === 'string') {\n        deepPath = deepPath.split('.'); // eslint-disable-line no-param-reassign\n    }\n\n    // iterate over all keys and delegate listener for all objects of given branch\n    for (let i = 0; i < deepPath.length; i++) {\n        // TODO: Array.prototype.slice method is slow\n        const listenPath = deepPath.slice(0, i);\n        const restPath = deepPath.slice(i + 1);\n\n        delegateListener(\n            object,\n            listenPath,\n            `_change:tree:${deepPath[i]}`,\n            createTreeListener({\n                handler,\n                restPath\n            })\n        );\n    }\n}\n","import undelegateListener from './_undelegatelistener';\n\n// removes tree listener from all object tree of fiven path\nexport default function removeTreeListener(object, deepPath, handler) {\n    if (typeof deepPath === 'string') {\n        deepPath = deepPath.split('.'); // eslint-disable-line no-param-reassign\n    }\n\n    // iterate over keys of the path and undelegate given handler (can be undefined)\n    for (let i = 0; i < deepPath.length; i++) {\n        // TODO: Array.prototype.slice is slow\n        const listenedPath = deepPath.slice(0, i);\n\n        undelegateListener(\n            object,\n            listenedPath,\n            `_change:tree:${deepPath[i]}`,\n            handler\n        );\n    }\n}\n","import selectNodes from './_selectnodes';\nimport $ from '../_mq';\n\nconst htmlReg = /</;\nconst customSelectorReg = /:bound\\(([^(]*)\\)/;\n\n// the function works just like DOM library accepting any kind of arg\n// (HTML string, Node, NodeList etc) bu allows to pass custom selector\n// eg :bound(KEY)\nexport default function getNodes(object, selector) {\n    let nodes;\n\n    if (\n        typeof selector === 'string'\n        && !htmlReg.test(selector)\n        && customSelectorReg.test(selector)\n    ) {\n        nodes = selectNodes(object, selector);\n    } else {\n        nodes = $(selector);\n    }\n\n    return nodes;\n}\n","import defaultBinders from './defaultbinders';\n\n// tries to find a binder for given node\nexport default function lookForBinder(node) {\n    for (let i = 0; i < defaultBinders.length; i++) {\n        const binder = defaultBinders[i].call(node, node);\n        if (binder) {\n            return binder;\n        }\n    }\n\n    return undefined;\n}\n","import input from './binders/input';\nimport textarea from './binders/textarea';\nimport select from './binders/select';\nimport progress from './binders/progress';\nimport output from './binders/output';\n\n// defaultBinders collection by default contains only one function-checker\nexport default [(node) => {\n    switch (node.tagName) {\n        case 'INPUT':\n            return input(node.type);\n        case 'TEXTAREA':\n            return textarea();\n        case 'SELECT':\n            return select(node.multiple);\n        case 'PROGRESS':\n            return progress();\n        case 'OUTPUT':\n            return output();\n        default:\n            return null;\n    }\n}];\n","import * as functions from './_lib';\n\nimport lookForBinder from './lookforbinder';\nimport chain from './chain';\nimport defaultBinders from './defaultbinders';\n\nexport default ({\n    ...functions,\n    lookForBinder,\n    chain,\n    defaultBinders\n});\n","import checkObjectType from '../_helpers/checkobjecttype';\nimport off from '../off';\nimport debounce from '../_helpers/debounce';\nimport forEach from '../_helpers/foreach';\nimport forOwn from '../_helpers/forown';\nimport addListener from './_addlistener';\nimport delegateListener from './_delegatelistener';\n\n// adds event listener\nexport default function on(object, givenNames, givenCallback, options) {\n    // throw error when object type is wrong\n    checkObjectType(object, 'on');\n\n    const isNamesVarArray = givenNames instanceof Array;\n\n    // allow to pass name-handler object\n    if (givenNames && typeof givenNames === 'object' && !isNamesVarArray) {\n        forOwn(givenNames, (namesObjCallback, namesObjName) => on(\n            object, namesObjName, namesObjCallback, givenCallback, options\n        ));\n        return object;\n    }\n\n    // convert a single event name into array\n    const names = isNamesVarArray ? givenNames : [givenNames];\n\n    const { triggerOnInit, once, debounce: debounceOption } = options || {};\n    let callback;\n    if (once) {\n        callback = function onceCallback() {\n            givenCallback.apply(this, arguments);\n            // remove event listener after its call\n            off(object, names, onceCallback);\n        };\n\n        // allow to remove event listener py passing original callback to \"off\"\n        callback._callback = givenCallback;\n    } else if (typeof debounceOption === 'number' || debounceOption === true) {\n        callback = debounce(givenCallback, debounceOption === true ? 0 : debounceOption, object);\n    } else {\n        callback = givenCallback;\n    }\n\n    forEach(names, (name) => {\n        const delegatedEventParts = typeof name === 'string' && name.split('@');\n\n        if (delegatedEventParts.length > 1) {\n            // if @ exists in event name then this is delegated event\n            const [path, delegatedName] = delegatedEventParts;\n            delegateListener(object, path, delegatedName, callback);\n        } else {\n            // if not, this is simple event\n            addListener(object, name, callback);\n        }\n    });\n\n    // call callback immediatelly if triggerOnInit is true\n    if (triggerOnInit) {\n        callback.call(object, options);\n    }\n\n    return object;\n}\n","function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nmodule.exports = _arrayWithHoles;","function _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nmodule.exports = _iterableToArrayLimit;","var arrayLikeToArray = require(\"./arrayLikeToArray\");\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}\n\nmodule.exports = _unsupportedIterableToArray;","function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nmodule.exports = _arrayLikeToArray;","function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nmodule.exports = _nonIterableRest;","import defs from '../_core/defs';\nimport removeListener from './_removelistener';\nimport $ from '../_mq';\nimport forEach from '../_helpers/foreach';\n\n// removes dom listener from nodes bound to given key\nexport default function removeDomListener(\n    object,\n    key,\n    eventName,\n    selector,\n    callback,\n    info\n) {\n    const def = defs.get(object);\n\n    if (!def) {\n        return object;\n    }\n\n    const { props } = def;\n    const propDef = props[key];\n\n    if (!propDef) {\n        return object;\n    }\n\n    const { bindings } = propDef;\n\n    if (bindings) {\n        // collect bound nodes and remove DOM event listener\n        const nodes = Array(bindings.length);\n        const eventNamespace = def.id + key;\n\n        forEach(bindings, (binding, index) => {\n            nodes[index] = binding.node;\n        });\n\n        $(nodes).off(`${eventName}.${eventNamespace}`, selector, callback);\n    }\n\n    // remove bind and unbind listeners from given key\n    removeListener(object, `bind:${key}`, callback, info);\n    removeListener(object, `unbind:${key}`, callback, info);\n\n    return object;\n}\n","import html2nodeList from './_html2nodelist';\nimport Init from './_init';\n\n// parses given HTML and returns mq instance\nexport default function parseHTML(html) {\n    return new Init(html2nodeList(html));\n}\n","import data from './_data';\n\nconst splitBySpaceReg = /\\s+/;\nconst splitByDotReg = /\\.(.+)/;\nconst randomID = `${Math.random().toString().replace('0.', 'x')}y`; // x12345y\n\n// checks an element against a selector\nfunction is(node, selector) {\n    return (node.matches\n            || node.webkitMatchesSelector\n            || node.mozMatchesSelector\n            || node.msMatchesSelector\n            || node.oMatchesSelector).call(node, selector);\n}\n\n// the function is used when a selector is given\nfunction delegateHandler(evt, selector, handler) {\n    const scopeSelector = `[${randomID}=\"${randomID}\"] `;\n    const splittedSelector = selector.split(',');\n\n    let matching = '';\n\n    for (let i = 0; i < splittedSelector.length; i++) {\n        const sel = splittedSelector[i];\n        matching += `${i === 0 ? '' : ','}${scopeSelector}${sel},${scopeSelector}${sel} *`;\n    }\n\n\n    this.setAttribute(randomID, randomID);\n\n    if (is(evt.target, matching)) {\n        handler.call(this, evt);\n    }\n\n    this.removeAttribute(randomID);\n}\n\n// adds event listener to a set of elemnts\nexport default function on(namesStr, selector, handler) {\n    const names = namesStr.split(splitBySpaceReg);\n    let delegate;\n\n    if (typeof selector === 'function') {\n        handler = selector; // eslint-disable-line no-param-reassign\n        selector = null; // eslint-disable-line no-param-reassign\n    }\n\n    if (selector) {\n        delegate = function uniqueDelegateHandler(evt) {\n            delegateHandler.call(this, evt, selector, handler);\n        };\n    }\n\n    for (let i = 0; i < names.length; i++) {\n        const [name, namespace] = names[i].split(splitByDotReg);\n\n        for (let j = 0; j < this.length; j++) {\n            const node = this[j];\n            const nodeID = node.b$ = node.b$ || ++data.nodeIndex; // eslint-disable-line no-plusplus\n            const events = data.allEvents[name + nodeID] = data.allEvents[name + nodeID] || [];\n\n            let exist = false;\n\n            for (let k = 0; k < events.length; k++) {\n                const event = events[k];\n\n                if (handler === event.handler && (!selector || selector === event.selector)) {\n                    exist = true;\n                    break;\n                }\n            }\n\n            if (!exist) {\n                events.push({\n                    delegate,\n                    handler,\n                    namespace,\n                    selector,\n                    nodeID,\n                    name\n                });\n\n                node.addEventListener(name, delegate || handler, false);\n            }\n        }\n    }\n\n    return this;\n}\n","import data from './_data';\n\nconst splitBySpaceReg = /\\s+/;\nconst splitByDotReg = /\\.(.+)/;\n\n// removes event handler from a set of elements\nexport default function off(namesStr, selector, handler) {\n    if (typeof selector === 'function') {\n        handler = selector; // eslint-disable-line no-param-reassign\n        selector = null; // eslint-disable-line no-param-reassign\n    }\n\n    const names = namesStr.split(splitBySpaceReg);\n\n    for (let i = 0; i < names.length; i++) {\n        const [name, namespace] = names[i].split(splitByDotReg);\n\n        for (let j = 0; j < this.length; j++) {\n            const node = this[j];\n\n            if (!name && namespace) {\n                for (let k = 0, keys = Object.keys(data.allEvents); k < keys.length; k++) {\n                    const events = data.allEvents[keys[k]];\n\n                    for (let l = 0; l < events.length; l++) {\n                        const event = events[i];\n                        if (event.namespace === namespace && event.nodeID === node.b$) {\n                            node.removeEventListener(event.name, event.delegate || event.handler);\n                            events.splice(l, 1);\n                            l -= 1;\n                        }\n                    }\n                }\n\n                continue;\n            }\n\n            const events = data.allEvents[name + node.b$];\n            if (events) {\n                for (let k = 0; k < events.length; k++) {\n                    const event = events[k];\n                    if (\n                        (!handler || handler === event.handler || handler === event.delegate)\n                        && (!namespace || namespace === event.namespace)\n                        && (!selector || selector === event.selector)\n                    ) {\n                        node.removeEventListener(name, event.delegate || event.handler);\n                        events.splice(k, 1);\n                        k -= 1;\n                    }\n                }\n            } else if (!namespace && !selector) {\n                node.removeEventListener(name, handler);\n            }\n        }\n    }\n\n    return this;\n}\n","import Init from './_init';\nimport data from './_data';\n\n// adds unique nodes to mq collection\nexport default function add(selector) {\n    const idMap = {};\n\n    let result;\n\n    const nodes = new Init(selector);\n\n    if (this.length) {\n        result = new Init();\n        for (let i = 0; i < this.length; i++) {\n            const node = this[i];\n            const nodeID = node.b$ = node.b$ || ++data.nodeIndex; // eslint-disable-line no-plusplus\n            idMap[nodeID] = 1;\n            result.push(node);\n        }\n\n        for (let i = 0; i < nodes.length; i++) {\n            const node = nodes[i];\n            const nodeID = node.b$ = node.b$ || ++data.nodeIndex; // eslint-disable-line no-plusplus\n            if (!idMap[nodeID]) {\n                idMap[nodeID] = 1;\n                result.push(node);\n            }\n        }\n    } else {\n        result = nodes;\n    }\n\n    return result;\n}\n","import initDefi from '../_core/init';\nimport defineProp from '../_core/defineprop';\nimport addListener from './_addlistener';\nimport $ from '../_mq';\nimport createDomEventHandler from './_createdomeventhandler';\nimport forEach from '../_helpers/foreach';\n\n// returns an object with event handlers used at addDomListener\nfunction createBindingHandlers({\n    fullEventName,\n    domEventHandler,\n    selector\n}) {\n    return {\n        bindHandler(evt = {}) {\n            const { node } = evt;\n            if (node) {\n                $(node).on(fullEventName, selector, domEventHandler);\n            }\n        },\n        unbindHandler(evt = {}) {\n            const { node } = evt;\n            if (node) {\n                $(node).off(fullEventName, selector, domEventHandler);\n            }\n        }\n    };\n}\n\n// adds DOM event listener for nodes bound to given property\nexport default function addDomListener(object, key, eventName, selector, callback, info) {\n    const def = initDefi(object);\n    const propDef = defineProp(object, key);\n\n    const domEventHandler = createDomEventHandler({\n        key,\n        object,\n        callback\n    });\n\n    // making possible to remove this event listener\n    domEventHandler._callback = callback;\n\n    const eventNamespace = def.id + key;\n    const fullEventName = `${eventName}.${eventNamespace}`;\n    const { bindHandler, unbindHandler } = createBindingHandlers({\n        fullEventName,\n        domEventHandler,\n        selector\n    });\n    const addBindListenerResult = addListener(object, `bind:${key}`, bindHandler, info);\n    const addUnbindListenerResult = addListener(object, `unbind:${key}`, unbindHandler, info);\n\n    // if events are added successfully then run bindHandler for every node immediately\n    // TODO: Describe why do we need addBindListenerResult and addUnbindListenerResult\n    if (addBindListenerResult && addUnbindListenerResult) {\n        const { bindings } = propDef;\n        if (bindings) {\n            forEach(bindings, ({ node }) => bindHandler({ node }));\n        }\n    }\n\n    return object;\n}\n","// returns DOM event handler\nexport default function createDomEventHandler({\n    key,\n    object,\n    callback\n}) {\n    return function domEventHandler(domEvent) {\n        const originalEvent = domEvent.originalEvent || domEvent;\n        // defiTriggerArgs are created when DOM event is triggered by trigger method\n        const triggerArgs = originalEvent.defiTriggerArgs;\n        const {\n            which, target, ctrlKey, altKey\n        } = domEvent;\n\n        if (triggerArgs) {\n            // if args are passed to trigger method then pass them to an event handler\n            callback.apply(object, triggerArgs);\n        } else {\n            // use the following object as an arg for event handler\n            callback.call(object, {\n                self: object,\n                node: this,\n                preventDefault: () => domEvent.preventDefault(),\n                stopPropagation: () => domEvent.stopPropagation(),\n                key,\n                domEvent,\n                originalEvent,\n                which,\n                target,\n                ctrlKey,\n                altKey\n            });\n        }\n    };\n}\n","import undelegateListener from '../../off/_undelegatelistener';\nimport triggerOne from '../../trigger/_triggerone';\n\n// the function is called when some part of a path is changed\n// it delegates event listener for new branch of an object and undelegates it for old one\n// used for non-asterisk events\nexport default function changeHandler({\n    previousValue,\n    value\n}, {\n    path,\n    name,\n    callback,\n    info\n} = triggerOne.latestEvent.info.delegatedData) {\n    if (value && typeof value === 'object') {\n        const delegateListener = require('.'); // fixing circular ref\n        delegateListener(value, path, name, callback, info);\n    }\n\n    if (previousValue && typeof previousValue === 'object') {\n        undelegateListener(previousValue, path, name, callback, info);\n    }\n}\n","import domEventReg from '../on/_domeventregexp';\nimport checkObjectType from '../_helpers/checkobjecttype';\nimport defs from '../_core/defs';\nimport triggerOne from './_triggerone';\nimport triggerDomEvent from './_triggerdomevent';\nimport forEach from '../_helpers/foreach';\n\n// triggers an event\nexport default function trigger(object, givenNames, ...triggerArgs) {\n    // throw error when object type is wrong\n    checkObjectType(object, 'trigger');\n\n    // allow to use either a string or an array of events\n    const names = givenNames instanceof Array ? givenNames : [givenNames];\n\n    const def = defs.get(object);\n\n    // if no definition do nothing\n    if (!def) {\n        return object;\n    }\n\n    const { events: allEvents } = def;\n\n    if (!allEvents) {\n        return object;\n    }\n\n    forEach(names, (name) => {\n        const domEvtExecResult = typeof name === 'string' && domEventReg.exec(name);\n\n        if (domEvtExecResult) {\n            // if EVT::KEY(SELECTOR) ia passed as event name then trigger DOM event\n            const [, eventName, key, selector] = domEvtExecResult;\n            triggerDomEvent(object, key, eventName, selector, triggerArgs);\n        } else {\n            // trigger ordinary event\n            triggerOne(object, name, triggerArgs);\n        }\n    });\n\n    return object;\n}\n","import triggerOneDOMEvent from './_triggeronedomevent';\nimport defs from '../_core/defs';\nimport forEach from '../_helpers/foreach';\n\n// triggers DOM event on bound nodes\nexport default function triggerDOMEvent(object, key, eventName, selector, triggerArgs) {\n    const def = defs.get(object);\n\n    if (!def) {\n        return;\n    }\n\n    const { props } = def;\n    const propDef = props[key];\n\n    if (!propDef) {\n        return;\n    }\n\n    const { bindings } = propDef;\n\n    if (!bindings) {\n        return;\n    }\n\n    forEach(bindings, ({ node }) => {\n        if (selector) {\n            // if selector is given trigger an event on all node descendants\n            const descendants = node.querySelectorAll(selector);\n            forEach(descendants, (descendant) => {\n                triggerOneDOMEvent({\n                    node: descendant,\n                    eventName,\n                    triggerArgs\n                });\n            });\n        } else {\n            // trigger an event for single node\n            triggerOneDOMEvent({\n                node,\n                eventName,\n                triggerArgs\n            });\n        }\n    });\n}\n","// triggers given DOM event on given node\nexport default function triggerOneDOMEvent({\n    node,\n    eventName,\n    triggerArgs\n}) {\n    const { Event } = window;\n    const event = new Event(eventName, {\n        bubbles: true,\n        cancelable: true\n    });\n\n    // defiTriggerArgs will be used in a handler created by addDOMListener\n    event.defiTriggerArgs = triggerArgs;\n\n    node.dispatchEvent(event);\n}\n","import initDefi from '../_core/init';\nimport checkObjectType from '../_helpers/checkobjecttype';\nimport defiError from '../_helpers/defierror';\nimport debounce from '../_helpers/debounce';\nimport forEach from '../_helpers/foreach';\nimport forOwn from '../_helpers/forown';\nimport assign from '../_helpers/assign';\nimport addSource from './_addsource';\nimport createCalcHandler from './_createcalchandler';\nimport defineProp from '../_core/defineprop';\n\n// defines a property which is dependend on other properties\nexport default function calc(object, target, sources, givenHandler, eventOptions) {\n    // throw error when object type is wrong\n    checkObjectType(object, 'calc');\n\n    if (target instanceof Object) {\n        /*\n         * accept an object\n         * this.calc({target: { source, handler, event } }, commonEventOptions);\n         */\n        forOwn(target, ({\n            source: itemSource,\n            handler: itemHandler,\n            options: itemEventOptions\n        }, itemTarget) => {\n            const commonEventOptions = sources;\n            const mergedEventOptions = {};\n\n            if (commonEventOptions) {\n                // extend event object by \"global\" event\n                assign(mergedEventOptions, commonEventOptions);\n            }\n\n            if (itemEventOptions) {\n                // extend event object by \"local\" event (\"event\" key of an object)\n                assign(mergedEventOptions, itemEventOptions);\n            }\n\n            calc(object, itemTarget, itemSource, itemHandler, mergedEventOptions);\n        });\n\n        return object;\n    }\n\n    if (typeof target !== 'string') {\n        throw defiError('calc:target_type', { target });\n    }\n\n    eventOptions = eventOptions || {}; // eslint-disable-line no-param-reassign\n    const def = initDefi(object);\n    const {\n        setOnInit = true,\n        debounceCalcOnInit = false,\n        debounceCalc = true,\n        debounceCalcDelay = 0\n    } = eventOptions;\n    const defaultHandler = (value) => value;\n    const handler = givenHandler || defaultHandler;\n    const allSources = [];\n    const syncCalcHandler = createCalcHandler({\n        object,\n        eventOptions,\n        allSources,\n        target,\n        def,\n        handler\n    });\n\n    let debouncedCalcHandler;\n    let calcHandler;\n\n    if (debounceCalcOnInit || debounceCalc) {\n        debouncedCalcHandler = debounce(syncCalcHandler, debounceCalcDelay);\n    }\n\n    defineProp(object, target);\n\n    if (!(sources instanceof Array)) {\n        sources = [sources]; // eslint-disable-line no-param-reassign\n    }\n\n    if (debounceCalc) {\n        calcHandler = debouncedCalcHandler;\n    } else {\n        calcHandler = syncCalcHandler;\n    }\n\n    forEach(sources, (source) => {\n        if (typeof source === 'string') {\n            // source object is current object\n            addSource({\n                calcHandler,\n                allSources,\n                sourceKey: source,\n                sourceObject: object,\n                eventOptions\n            });\n        } else {\n            // source object is external object\n            if (!source || typeof source !== 'object') {\n                throw defiError('calc:source_type', { source });\n            }\n\n            const sourceKey = source.key;\n            const sourceObject = source.object;\n            if (sourceKey instanceof Array) {\n                // many keys are passed\n                forEach(sourceKey, (sourceKeyItem) => {\n                    addSource({\n                        calcHandler,\n                        allSources,\n                        sourceKey: sourceKeyItem,\n                        sourceObject,\n                        eventOptions\n                    });\n                });\n            } else {\n                // one key is passed\n                addSource({\n                    calcHandler,\n                    allSources,\n                    sourceKey,\n                    sourceObject,\n                    eventOptions\n                });\n            }\n        }\n    });\n\n    if (setOnInit) {\n        if (debounceCalcOnInit) {\n            debouncedCalcHandler();\n        } else {\n            syncCalcHandler();\n        }\n    }\n\n    return object;\n}\n","import addListener from '../on/_addlistener';\nimport addTreeListener from '../on/_addtreelistener';\nimport defiError from '../_helpers/defierror';\n\n// adds a source to a source list and adds needed event listener to a it\nexport default function addSource({\n    calcHandler,\n    allSources,\n    sourceKey,\n    sourceObject,\n    eventOptions\n}) {\n    let { exactKey = false } = eventOptions;\n    let isDelegated = false;\n\n    // source key must be a string\n    if (typeof sourceKey !== 'string') {\n        throw defiError('calc:source_key_type', { sourceKey });\n    }\n\n    // source object must be an object\n    if (!sourceObject || typeof sourceObject !== 'object') {\n        throw defiError('calc:source_object_type', { sourceObject });\n    }\n\n    if (!exactKey) {\n        const deepPath = sourceKey.split('.');\n\n        // if something like a.b.c is used as a key\n        if (deepPath.length > 1) {\n            isDelegated = true;\n            // TODO: Avoid collisions with bindings by using another event name\n            // ... instead of _change:tree:xxx\n            addTreeListener(sourceObject, deepPath, calcHandler);\n        } else {\n            exactKey = true;\n        }\n    }\n\n\n    if (exactKey) {\n        // normal handler\n        addListener(sourceObject, `_change:deps:${sourceKey}`, calcHandler);\n    }\n\n    allSources.push({\n        sourceKey,\n        sourceObject,\n        isDelegated\n    });\n}\n","import set from '../set';\nimport deepFind from '../_helpers/deepfind';\nimport forEach from '../_helpers/foreach';\n\n// creates event handler for target object which will be fired when a source is changed\nexport default function createCalcHandler({\n    object,\n    eventOptions,\n    allSources,\n    target,\n    def,\n    handler\n}) {\n    return function calcHandler(changeEvent = {}) {\n        const values = [];\n        const { protector = {} } = changeEvent;\n        const protectKey = target + def.id;\n        const { promiseCalc } = eventOptions;\n        const setEventOptions = {\n            protector,\n            ...eventOptions,\n            ...changeEvent\n        };\n\n        if (protectKey in protector) {\n            return;\n        }\n\n        protector[protectKey] = true;\n\n        forEach(allSources, ({\n            sourceObject,\n            sourceKey,\n            isDelegated\n        }) => {\n            const value = isDelegated ? deepFind(sourceObject, sourceKey) : sourceObject[sourceKey];\n            values.push(value);\n        });\n\n        let targetValue = handler.apply(object, values);\n\n        if (promiseCalc) {\n            if (!(targetValue instanceof Promise)) {\n                targetValue = Promise.resolve(targetValue);\n            }\n\n            targetValue\n                .then((promiseResult) => set(object, target, promiseResult, setEventOptions))\n                .catch((e) => {\n                    throw Error(e);\n                });\n        } else {\n            set(object, target, targetValue, setEventOptions);\n        }\n    };\n}\n","// gets value of a property in nested object\n// eg \"d\" from a.b.c.d\nexport default function deepFind(obj, givenPath) {\n    const paths = typeof givenPath === 'string' ? givenPath.split('.') : givenPath;\n    let current = obj;\n\n    for (let i = 0; i < paths.length; ++i) {\n        if (typeof current[paths[i]] === 'undefined') {\n            return undefined;\n        }\n\n        current = current[paths[i]];\n    }\n\n    return current;\n}\n","import initDefi from '../_core/init';\nimport defineProp from '../_core/defineprop';\nimport getNodes from './_getnodes';\nimport createBindingSwitcher from './_createbindingswitcher';\nimport bindSingleNode from './_bindsinglenode';\nimport checkObjectType from '../_helpers/checkobjecttype';\nimport defiError from '../_helpers/defierror';\nimport forEach from '../_helpers/foreach';\nimport forOwn from '../_helpers/forown';\nimport addTreeListener from '../on/_addtreelistener';\n\n// initializes binsing between a property of an object to HTML node\nexport default function bindNode(object, key, node, binder, eventOptions) {\n    // throw error when object type is wrong\n    checkObjectType(object, 'bindNode');\n\n    eventOptions = eventOptions || {}; // eslint-disable-line no-param-reassign\n    binder = binder || {}; // eslint-disable-line no-param-reassign\n\n    initDefi(object);\n\n    // throw an error when key is falsy\n    if (!key) {\n        throw defiError('binding:falsy_key');\n    }\n\n    if (key instanceof Array) {\n        /*\n         * accept array of keys\n         * this.bindNode(['a', 'b', 'c'], node)\n         */\n        forEach(key, (itemKey) => bindNode(object, itemKey, node, binder, eventOptions));\n\n        return object;\n    }\n\n\n    if (typeof key === 'object') {\n        forOwn(key, (keyObjValue, keyObjKey) => {\n            // binder means eventOptions\n            eventOptions = binder; // eslint-disable-line no-param-reassign\n\n            if (\n                keyObjValue\n                && keyObjValue.constructor === Object\n                && 'node' in keyObjValue\n            ) {\n                // this.bindNode({ key: { node: $(), binder } ) }, { on: 'evt' }, { silent: true });\n                bindNode(\n                    object, keyObjKey, keyObjValue.node,\n                    keyObjValue.binder || node, eventOptions\n                );\n            } else if (\n                keyObjValue\n                && keyObjValue.constructor === Array\n                && keyObjValue.length\n                && keyObjValue[0].constructor === Object\n                && 'node' in keyObjValue[0]\n            ) {\n                // this.bindNode({ key: [{\n                //   node: $(),\n                //   binder\n                // }] ) }, { on: 'evt' }, { silent: true });\n                forEach(keyObjValue, (keyObjValueItem) => {\n                    bindNode(\n                        object, keyObjKey, keyObjValueItem.node,\n                        keyObjValueItem.binder || node, eventOptions\n                    );\n                });\n            } else {\n                // this.bindNode({ key: $() }, { on: 'evt' }, { silent: true });\n                bindNode(object, keyObjKey, keyObjValue, node, eventOptions);\n            }\n        });\n\n        return object;\n    }\n\n    const {\n        optional = false,\n        exactKey = false\n    } = eventOptions;\n    const $nodes = getNodes(object, node);\n\n    // check node existence\n    if (!$nodes.length) {\n        if (optional) {\n            return object;\n        }\n\n        throw defiError('binding:node_missing', { key, node });\n    }\n\n    if (!exactKey) {\n        const deepPath = key.split('.');\n        const deepPathLength = deepPath.length;\n\n        if (deepPathLength > 1) {\n            // handle binding when key arg includes dots (eg \"a.b.c.d\")\n            const bindingSwitcher = createBindingSwitcher({\n                object,\n                deepPath,\n                $nodes,\n                binder,\n                eventOptions,\n                bindNode\n            });\n\n            addTreeListener(object, deepPath.slice(0, deepPathLength - 1), bindingSwitcher);\n\n            bindingSwitcher();\n\n            return object;\n        }\n    }\n\n    const propDef = defineProp(object, key);\n\n    // handle binding for every node separately\n    forEach($nodes, (oneNode) => bindSingleNode(object, {\n        $nodes,\n        node: oneNode,\n        key,\n        eventOptions,\n        binder,\n        propDef\n    }));\n\n    return object;\n}\n","import defs from '../_core/defs';\nimport $ from '../_mq';\nimport forEach from '../_helpers/foreach';\n\nconst customSelectorReg = /\\s*:bound\\(([^(]*)\\)\\s*([\\S\\s]*)\\s*/;\nconst randomAttr = `${Math.random().toString().replace('0.', 'x')}y`; // x12345y\n\n// the function selects nodes based on a selector (including custom values, eg :bound)\n// TODO: selectNodes looks not good, it needs to be refactored and accelerated if possible\nexport default function selectNodes(object, givenSelector) {\n    const { props } = defs.get(object);\n    const selectors = givenSelector.split(',');\n    let result = $();\n\n    forEach(selectors, (selector) => {\n        const execResult = customSelectorReg.exec(selector);\n        if (execResult) {\n            const boundKey = execResult[1];\n            const subSelector = execResult[2];\n            const propDef = props[boundKey];\n\n            if (propDef) {\n                const { bindings } = propDef;\n                if (bindings) {\n                    const boundNodes = Array(bindings.length);\n                    forEach(bindings, (binding, i) => {\n                        boundNodes[i] = binding.node;\n                    });\n\n                    // if native selector passed after :bound(KEY) is not empty string\n                    // for example \":bound(KEY) .my-selector\"\n                    if (subSelector) {\n                        // if native selector contains children selector\n                        // for example \":bound(KEY) > .my-selector\"\n                        if (subSelector.indexOf('>') === 0) {\n                            // selecting children\n                            forEach(boundNodes, (node) => {\n                                node.setAttribute(randomAttr, randomAttr);\n                                const selected = node.querySelectorAll(`[${randomAttr}=\"${randomAttr}\"] ${subSelector}`);\n                                result = result.add(selected);\n                                node.removeAttribute(randomAttr);\n                            });\n                        } else {\n                            // if native selector doesn't contain children selector\n                            forEach(boundNodes, (node) => {\n                                const selected = node.querySelectorAll(subSelector);\n                                result = result.add(selected);\n                            });\n                        }\n                    } else {\n                        // if native selector is empty string just add bound nodes to result\n                        result = result.add(boundNodes);\n                    }\n                }\n            }\n        } else {\n            // if it's native selector (no custom things)\n            result = result.add(selector);\n        }\n    });\n\n    return result;\n}\n","import unbindNode from '../unbindnode';\n\n// returns a function which re-adds binding when object branch is changed\n// the function is called by bindNode when something like\n// 'foo.bar.baz' is passed to it as key argument value\n// this is one of the hardest things in the framework to understand\nexport default function createBindingSwitcher({\n    object,\n    deepPath,\n    $nodes,\n    binder,\n    eventOptions,\n    bindNode\n}) {\n    return function bindingSwitcher(changeEvent = {}) {\n        const deepPathLength = deepPath.length;\n        const lastDeepPathItem = deepPath[deepPathLength - 1];\n        const {\n            value, // new value of a branch\n            previousValue, // previous value of a branch\n            restPath // path starting currently changed branch (passed by addTreeListener)\n        } = changeEvent;\n        let target; // an object to call bindNode\n        let previousTarget; // an object to call unbindNode\n\n\n        if (value && typeof value === 'object' && restPath) {\n            // if rest path is given and new value is an object\n            target = value;\n            for (let i = 0; i < restPath.length; i++) {\n                target = target[restPath[i]];\n                if (!target) {\n                    break;\n                }\n            }\n        } else {\n            // if rest path is not given\n            target = object;\n            for (let i = 0; i < deepPathLength - 1; i++) {\n                target = target[deepPath[i]];\n                if (!target) {\n                    break;\n                }\n            }\n        }\n\n        // if rest path is given and previous value is an object\n        if (previousValue && typeof previousValue === 'object' && restPath) {\n            previousTarget = previousValue;\n            for (let i = 0; i < restPath.length; i++) {\n                previousTarget = previousTarget[restPath[i]];\n                if (!previousTarget) {\n                    break;\n                }\n            }\n        }\n\n        // add binding for new target\n        if (target && typeof target === 'object') {\n            bindNode(target, lastDeepPathItem, $nodes, binder, eventOptions);\n        }\n\n        // remove binding for previously used object\n        if (previousTarget && typeof previousTarget === 'object') {\n            unbindNode(previousTarget, lastDeepPathItem, $nodes);\n        }\n    };\n}\n","import removeListener from '../off/_removelistener';\nimport triggerOne from '../trigger/_triggerone';\nimport forEach from '../_helpers/foreach';\n\nconst spaceReg = /\\s+/;\n\n// the function removes single binding for single object\n// called by unbindNode\nexport default function removeBinding({\n    object,\n    key,\n    eventOptions,\n    binding\n}) {\n    const {\n        bindingOptions,\n        binder,\n        node,\n        nodeHandler,\n        objectHandler\n    } = binding;\n    const { destroy, on } = binder;\n    const { silent } = eventOptions;\n\n    // if \"on\" is a function then disable it\n    // we cannot \"turn off\" custom listener defined by a programmer\n    // programmer needs to remove custom listener maually inside binder.destroy\n    if (typeof on === 'function') {\n        nodeHandler.disabled = true;\n    } else if (typeof on === 'string') {\n        // remove DOM event listener\n        // removeEventListener is faster than \"on\" method from any DOM library\n        forEach(\n            on.split(spaceReg),\n            (evtName) => node.removeEventListener(evtName, nodeHandler)\n        );\n    }\n\n    // remove object event listener\n    removeListener(object, `_change:bindings:${key}`, objectHandler);\n\n    // if binder.destroy is given call it\n    if (destroy) {\n        destroy.call(node, bindingOptions);\n    }\n\n    // fire events\n    if (!silent) {\n        const extendedEventOptions = {\n            key,\n            node,\n            ...eventOptions\n        };\n\n        triggerOne(object, `unbind:${key}`, extendedEventOptions);\n        triggerOne(object, 'unbind', extendedEventOptions);\n    }\n}\n","import lookForBinder from '../lookforbinder';\nimport createNodeHandler from './_createnodehandler';\nimport createObjectHandler from './_createobjecthandler';\nimport triggerOne from '../trigger/_triggerone';\nimport addListener from '../on/_addlistener';\nimport debounce from '../_helpers/debounce';\nimport assign from '../_helpers/assign';\nimport forEach from '../_helpers/foreach';\n\nconst spaceReg = /\\s+/;\n\n// handles binding for single property & node\n// the function is used at bindNode\nexport default function bindSingleNode(object, {\n    binder: givenBinder,\n    key,\n    $nodes,\n    node,\n    eventOptions,\n    propDef\n}) {\n    const {\n        silent,\n        getValueOnBind,\n        setValueOnBind,\n        // TODO: We probably need some general flag to cancel or force debouncing\n        // ... which overrides the following flags (something like debounceBinding)\n        debounceSetValue = true,\n        debounceGetValue = true,\n        debounceSetValueOnBind = false,\n        debounceGetValueOnBind = false,\n        debounceSetValueDelay = 0,\n        debounceGetValueDelay = 0,\n        useExactBinder = false\n    } = eventOptions;\n    // create bindings array in property definition object\n    const bindings = propDef.bindings = propDef.bindings || [];\n    const { value } = propDef;\n    const bindingOptions = {\n        self: object,\n        key,\n        value,\n        $nodes,\n        node\n    };\n    let isUndefined = typeof value === 'undefined';\n    let binder;\n    let objectHandler;\n    let nodeHandler;\n\n    // get actual binder\n    if (givenBinder !== null) {\n        // by default binder passed to bindNode is extended by default binder\n        // useExactBinder turns this behavior off\n        if (useExactBinder) {\n            binder = givenBinder;\n        } else {\n            // getting default binder\n            const foundBinder = lookForBinder(node);\n\n            // if default binder is found\n            if (foundBinder) {\n                // extend found binder by given binder\n                if (givenBinder) {\n                    assign(foundBinder, givenBinder);\n                }\n\n                binder = foundBinder;\n            } else {\n                // default binder is not found\n                binder = givenBinder || {};\n            }\n        }\n    }\n\n    const {\n        getValue, setValue, on, initialize\n    } = binder;\n\n    // call binder.initialize\n    if (initialize) {\n        initialize.call(node, bindingOptions);\n    }\n\n    // add needed event handlers to given node when getValue is given\n    if (getValue) {\n        const syncNodeHandler = createNodeHandler({\n            object,\n            key,\n            node,\n            propDef,\n            binder,\n            bindingOptions\n        });\n\n        let debouncedNodeHandler;\n\n        if (debounceGetValue || debounceGetValueOnBind) {\n            debouncedNodeHandler = debounce(syncNodeHandler, debounceGetValueDelay);\n        }\n\n        if (debounceGetValue) {\n            nodeHandler = debouncedNodeHandler;\n        } else {\n            nodeHandler = syncNodeHandler;\n        }\n\n        // TODO: Throw error when \"on\" and maybe other binder properties has wrong type\n        if (typeof on === 'function') {\n            on.call(node, nodeHandler, bindingOptions);\n        } else if (typeof on === 'string') {\n            // addEventListener is faster than \"on\" method from any DOM library\n            forEach(\n                on.split(spaceReg),\n                (evtName) => node.addEventListener(evtName, nodeHandler)\n            );\n        }\n\n        if ((isUndefined && getValueOnBind !== false) || getValueOnBind === true) {\n            if (debounceGetValueOnBind) {\n                debouncedNodeHandler();\n            } else {\n                syncNodeHandler();\n            }\n        }\n\n        isUndefined = typeof propDef.value === 'undefined';\n    }\n\n    // add needed event handlers to the object when setValue is given\n    if (setValue) {\n        const syncObjectHandler = createObjectHandler({\n            node,\n            propDef,\n            binder,\n            bindingOptions,\n            eventOptions\n        });\n\n        let debouncedObjectHandler;\n\n        if (debounceSetValue || debounceSetValueOnBind) {\n            debouncedObjectHandler = debounce(syncObjectHandler, debounceSetValueDelay);\n        }\n\n        if (debounceSetValue) {\n            objectHandler = debouncedObjectHandler;\n        } else {\n            objectHandler = syncObjectHandler;\n        }\n\n        // TODO: Is it possible to get previous value of a property?\n        addListener(object, `_change:bindings:${key}`, objectHandler, { skipChecks: true });\n\n        if ((!isUndefined && setValueOnBind !== false) || setValueOnBind === true) {\n            if (debounceSetValueOnBind) {\n                debouncedObjectHandler();\n            } else {\n                syncObjectHandler();\n            }\n        }\n    }\n\n    // add binding data to bindings array\n    bindings.push({\n        on,\n        node,\n        binder,\n        objectHandler,\n        nodeHandler,\n        bindingOptions\n    });\n\n    // fire events\n    if (!silent) {\n        const extendedEventOptions = {\n            key,\n            node,\n            ...eventOptions\n        };\n\n        triggerOne(object, `bind:${key}`, extendedEventOptions);\n        triggerOne(object, 'bind', extendedEventOptions);\n    }\n}\n","import input from './input';\n\n// returns a binder for textarea element\nexport default function textarea() {\n    // textarea behaves just like text input\n    return input('text');\n}\n","// returns a binder for select element\nexport default function select(multiple) {\n    if (multiple) {\n        return {\n            on: 'change',\n            getValue() {\n                const { options } = this;\n                const result = [];\n\n                for (let i = 0; options.length > i; i++) {\n                    if (options[i].selected) {\n                        result.push(options[i].value);\n                    }\n                }\n\n                return result;\n            },\n            setValue(givenValue) {\n                const { options } = this;\n                const value = typeof givenValue === 'string' ? [givenValue] : givenValue;\n                for (let i = options.length - 1; i >= 0; i--) {\n                    options[i].selected = ~value.indexOf(options[i].value);\n                }\n            }\n        };\n    }\n\n    return {\n        on: 'change',\n        getValue() {\n            return this.value;\n        },\n        setValue(value) {\n            this.value = value;\n\n            if (!value) {\n                const { options } = this;\n                for (let i = options.length - 1; i >= 0; i--) {\n                    if (!options[i].value) {\n                        options[i].selected = true;\n                        break;\n                    }\n                }\n            }\n        }\n    };\n}\n","import input from './input';\n\n// returns a binder for textarea element\nexport default function progress() {\n    return input();\n}\n","// returns a binder for output element\nexport default function output() {\n    return {\n        on: null,\n        getValue() {\n            return this.value || this.textContent;\n        },\n        setValue(value) {\n            const property = 'form' in this ? 'value' : 'textContent';\n            this[property] = value === null ? '' : `${value}`;\n        }\n    };\n}\n","import is from '../_helpers/is';\nimport set from '../set';\n\n// returns a function which called when bound node state is changed (eg DOM event is fired)\nexport default function createNodeHandler({\n    object,\n    key,\n    node,\n    propDef,\n    binder,\n    bindingOptions\n}) {\n    return function nodeHandler(domEvent = {}) {\n        // nodeHandler.disabled = true is set in unbindNode\n        // we cannot \"turn off\" binder.on when its value is a function\n        // developer needs to clean memory (\"turn off\" callback) manualy in binder.destroy\n        if (nodeHandler.disabled) {\n            return;\n        }\n\n        const previousValue = propDef.value;\n        const {\n            which, target, ctrlKey, altKey\n        } = domEvent;\n        const { getValue } = binder;\n        const value = getValue.call(node, {\n            previousValue,\n            domEvent,\n            originalEvent: domEvent.originalEvent || domEvent, // jQuery thing\n            // will throw \"preventDefault is not a function\" when domEvent is empty object\n            preventDefault: () => domEvent.preventDefault(),\n            // will throw \"stopPropagation is not a function\" when domEvent is empty object\n            stopPropagation: () => domEvent.stopPropagation(),\n            which,\n            target,\n            ctrlKey,\n            altKey,\n            ...bindingOptions\n        });\n\n        if (!is(value, previousValue)) {\n            set(object, key, value, {\n                fromNode: true,\n                // the following properties are needed to avoid circular changes\n                // they are used at objectHandler\n                changedNode: node,\n                onChangeValue: value,\n                binder\n            });\n        }\n    };\n}\n","// returns a function which is called when property value is changed\nexport default function createObjectHandler({\n    node,\n    propDef,\n    binder,\n    bindingOptions\n}) {\n    return function objectHandler(eventOptions = {}) {\n        const { value } = propDef;\n        const { onChangeValue, changedNode, binder: evtBinder } = eventOptions;\n        const { setValue } = binder;\n        // a dirty hack for https://github.com/matreshkajs/matreshka/issues/19\n        const dirtyHackValue = onChangeValue === 'string' && typeof value === 'number'\n            ? `${value}` : value;\n\n        // don't call setValue if a property is changed via getValue of the same binder\n        if (changedNode === node && onChangeValue === dirtyHackValue && evtBinder === binder) {\n            return;\n        }\n\n        setValue.call(node, value, {\n            value,\n            ...bindingOptions\n        });\n    };\n}\n","import defs from './_core/defs';\nimport checkObjectType from './_helpers/checkobjecttype';\n\n// the function returns bound node(s)\nexport default function bound(object, key, { all } = { all: false }) {\n    // throw error when object type is wrong\n    checkObjectType(object, 'bound');\n\n    // if no key or falsy key is given\n    if (!key) {\n        return all ? [] : null;\n    }\n\n    const def = defs.get(object);\n    const propDef = def.props[key];\n\n    let nodes;\n\n    if (propDef) {\n        const { bindings } = propDef;\n        nodes = (bindings && bindings.map(({ node }) => node)) || [];\n    } else {\n        nodes = [];\n    }\n\n    return all ? nodes : nodes[0] || null;\n}\n","import unbindNode from './unbindnode';\nimport triggerOne from './trigger/_triggerone';\nimport removeListener from './off/_removelistener';\nimport defs from './_core/defs';\nimport checkObjectType from './_helpers/checkobjecttype';\nimport defiError from './_helpers/defierror';\nimport forEach from './_helpers/foreach';\n\n// removes a property, its bindings and its events\n// TODO: remove function does not correctly removes delegated events, bindings, tree listeners etc\nexport default function remove(object, givenKey, eventOptions) {\n    // throw error when object type is wrong\n    checkObjectType(object, 'remove');\n\n    eventOptions = eventOptions || {}; // eslint-disable-line no-param-reassign\n    const def = defs.get(object);\n    const { silent } = eventOptions;\n    // allow to pass single key or an array of keys\n    const keys = givenKey instanceof Array ? givenKey : [givenKey];\n\n    for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n\n        // if non-string is passed as a key\n        if (typeof key !== 'string') {\n            throw defiError('remove:key_type', { key });\n        }\n\n        const props = def && def.props;\n        const propDef = props && props[key];\n\n        // if no object definition then simply delete the property\n        if (!propDef) {\n            delete object[key];\n            continue;\n        }\n\n        const { value } = propDef;\n\n        // remove all bindings\n        unbindNode(object, key);\n\n        // TODO: Manual listing of event prefixes may cause problems in future\n        const removeEventPrefies = [\n            '_change:deps',\n            '_change:bindings',\n            '_change:delegated',\n            '_change:tree',\n            'change',\n            'beforechange',\n            'bind',\n            'unbind'\n        ];\n\n        // remove all events\n        forEach(removeEventPrefies, (prefix) => removeListener(object, `${prefix}:${key}`));\n\n        // delete property definition\n        delete props[key];\n\n        // delete the property itself\n        delete object[key];\n\n        const extendedEventOptions = {\n            key,\n            value,\n            ...eventOptions\n        };\n\n        // trigger delegated events logic removal for asterisk events (*.*.*@foo)\n        triggerOne(object, '_delete:delegated', extendedEventOptions);\n\n        // fire events if \"silent\" is not true\n        if (!silent) {\n            triggerOne(object, 'delete', extendedEventOptions);\n            triggerOne(object, `delete:${key}`, extendedEventOptions);\n        }\n    }\n}\n","import initDefi from './_core/init';\nimport defineProp from './_core/defineprop';\nimport checkObjectType from './_helpers/checkobjecttype';\nimport set from './set';\nimport defiError from './_helpers/defierror';\nimport forOwn from './_helpers/forown';\nimport forEach from './_helpers/foreach';\n\n// creates property mediator\nfunction createMediator({\n    object,\n    propDef,\n    key,\n    mediator\n}) {\n    return function propMediator(value) {\n        // args: value, previousValue, key, object itself\n        return mediator.call(object, value, propDef.value, key, object);\n    };\n}\n\n// transforms property value on its changing\nexport default function mediate(object, givenKeys, mediator) {\n    // throw error when object type is wrong\n    checkObjectType(object, 'mediate');\n\n    const isKeysArray = givenKeys instanceof Array;\n\n    // allow to use key-mediator object as another method variation\n    if (typeof givenKeys === 'object' && !isKeysArray) {\n        forOwn(givenKeys, (objVal, objKey) => mediate(object, objKey, objVal));\n        return object;\n    }\n\n    initDefi(object);\n\n    // allow to use both single key and an array of keys\n    const keys = isKeysArray ? givenKeys : [givenKeys];\n\n    forEach(keys, (key) => {\n        // if non-string is passed as a key\n        if (typeof key !== 'string') {\n            throw defiError('mediate:key_type', { key });\n        }\n\n        const propDef = defineProp(object, key);\n\n        const propMediator = propDef.mediator = createMediator({\n            object,\n            propDef,\n            key,\n            mediator\n        });\n\n        // set new value\n        set(object, key, propMediator(propDef.value), {\n            fromMediator: true\n        });\n    });\n\n    return object;\n}\n","import checkObjectType from './_helpers/checkobjecttype';\nimport * as functions from './_lib';\nimport forEach from './_helpers/foreach';\n\n// create a prototype of ChainClass\n// store target object at \"object\" property\nconst prototype = {\n    constructor(object) {\n        this.object = object;\n    }\n};\n\nconst funcNames = Object.keys(functions);\n\n// iterate over all universal methods\nfor (let i = 0; i < funcNames.length; i++) {\n    const funcName = funcNames[i];\n    const method = functions[funcName];\n\n    // create every chained method\n    prototype[funcName] = function chainedMethod() {\n        const args = [this.object];\n\n        forEach(arguments, (argument) => {\n            args.push(argument);\n        });\n\n        method(...args);\n\n        // returning this is important for chained calls\n        return this;\n    };\n}\n\n\nconst ChainClass = function ChainClass(object) {\n    this.object = object;\n};\n\nChainClass.prototype = prototype;\n\n// the function allows to chain static function calls on any object\nexport default function chain(object) {\n    // check for type and throw an error if it is not an object and is not a function\n    checkObjectType(object, 'chain');\n\n    return new ChainClass(object);\n}\n"],"sourceRoot":""}